'use client'

import { useRef, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { OrbitControls } from '@react-three/drei'
import * as THREE from 'three'
import { useAudio } from './AudioContext'
import { AnimationSequence } from './animation-sequence'

export function MercuryBlob({ position = [0, 0, 0] as [number, number, number], scale = 1, blobId = 0, forceDotMatrix = false }) {
  const meshRef = useRef<THREE.Object3D>(null)
  const { controls, isPlaying, audioSrc, audioData } = useAudio()
  
  // Safe audio data with defaults
  const safeAudioData = audioData || {
    volume: 0,
    peakVolume: 0,
    averageVolume: 0,
    dbLevel: -60,
    bassLevel: 0,
    midLevel: 0,
    highLevel: 0,
  }
  
  // Get the shape for this specific blob
  const getBlobShape = () => {
    const allShapes = [
      'sphere', 'icosahedron', 'cube', 'torus', 'octahedron', 
      'dodecahedron', 'tetrahedron', 'cylinder', 'cone', 
      'torusKnot', 'ring', 'capsule', 'prism', 'pyramid',
      'star', 'heart', 'mobius', 'klein'
    ]
    
    if (blobId === 0) {
      return controls.shape || 'sphere'
    } else {
      const availableShapes = allShapes.filter(shape => shape !== (controls.shape || 'sphere'))
      const seedValue = blobId * 7 + (controls.shape || 'sphere').length
      const shapeIndex = Math.floor(seedValue * 2.34567) % availableShapes.length
      return availableShapes[shapeIndex]
    }
  }
  
  const blobShape = getBlobShape()
  
  // FIXED SHADER MATERIAL with ALL UNIFORMS
  const material = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        isPlaying: { value: 0 },
        
        // Audio data
        volume: { value: 0 },
        midLevel: { value: 0 },
        highLevel: { value: 0 },
        bassLevel: { value: 0 },
        
        // Visual controls
        noiseScale: { value: 2.2 },
        noiseForce: { value: 1.5 },
        goopiness: { value: 1.5 },
        liquidity: { value: 2.0 },
        split: { value: 0.8 },
        metallic: { value: 0.7 },
        
        // Colors
        color1: { value: new THREE.Color('#00f2ff') },
        color2: { value: new THREE.Color('#ff00a8') },
        color3: { value: new THREE.Color('#7000ff') },
        
        // Audio reactivity
        audioReactivity: { value: 6.0 },
        
        // *** REAL PHYSICAL PROPERTIES ***
        viscosity: { value: 0.5 },
        surfaceTension: { value: 0.7 },
        density: { value: 1.0 },
        elasticity: { value: 0.5 },
        
        // *** PUDDLE MODE - FIXED! ***
        puddleMode: { value: 0.0 },
        
        // DRAMATIC EFFECTS
        splitIntensity: { value: 0.0 },
        tentacleMode: { value: 0.0 },
        liquidMerge: { value: 0.0 },
        shattered: { value: 0.0 },
        vortex: { value: 0.0 },
        
        // SURFACE CONTROLS - FIXED!
        chrome: { value: 0.0 },
        pearl: { value: 0.0 },
        holographic: { value: 0.0 },
        glass: { value: 0.0 },
        roughness: { value: 0.0 },    // MISSING UNIFORM ADDED!
        
        // VISUAL EFFECTS
        contrast: { value: 1.0 },
        bloom: { value: 0.0 },
        grain: { value: 0.0 },
        grainSize: { value: 1.0 },
        
        // MODES
        dotMatrix: { value: 0.0 },
        wireframe: { value: 0.0 },
        
        // COLOR FLOW UNIFORMS
        colorFlow: { value: 0.0 },
        colorShift1: { value: 0.0 },
        colorShift2: { value: 0.0 },
        colorShift3: { value: 0.0 },
      },
      vertexShader: `
        uniform float time;
        uniform float isPlaying;
        uniform float volume;
        uniform float midLevel;
        uniform float highLevel;
        uniform float bassLevel;
        
        uniform float noiseScale;
        uniform float noiseForce;
        uniform float goopiness;
        uniform float liquidity;
        uniform float split;
        uniform float audioReactivity;
        
        // *** PHYSICAL PROPERTIES ***
        uniform float viscosity;
        uniform float surfaceTension;
        uniform float density;
        uniform float elasticity;
        
        // *** PUDDLE MODE ***
        uniform float puddleMode;
        
        // DRAMATIC EFFECTS uniforms
        uniform float splitIntensity;
        uniform float tentacleMode;
        uniform float liquidMerge;
        uniform float shattered;
        uniform float vortex;
        uniform float dotMatrix;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;
        varying float vAudioIntensity;
        varying float vDeformationAmount;
        varying vec3 vWorldPosition;
        
        // Enhanced noise functions
        float hash(float n) { return fract(sin(n) * 1e4); }
        
        float noise(vec3 x) {
          const vec3 step = vec3(110, 241, 171);
          vec3 i = floor(x);
          vec3 f = fract(x);
          f = f * f * (3.0 - 2.0 * f);
          return mix(mix(mix( hash(dot(i, step)), hash(dot(i + vec3(1,0,0), step)), f.x),
                         mix( hash(dot(i + vec3(0,1,0), step)), hash(dot(i + vec3(1,1,0), step)), f.x), f.y),
                     mix(mix( hash(dot(i + vec3(0,0,1), step)), hash(dot(i + vec3(1,0,1), step)), f.x),
                         mix( hash(dot(i + vec3(0,1,1), step)), hash(dot(i + vec3(1,1,1), step)), f.x), f.y), f.z);
        }
        
        // Fractal noise for complex effects
        float fbm(vec3 p) {
          float value = 0.0;
          float amplitude = 0.5;
          float frequency = 1.0;
          for (int i = 0; i < 5; i++) {
            value += amplitude * noise(p * frequency);
            frequency *= 2.1;
            amplitude *= 0.45;
          }
          return value;
        }
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          
          // Physical time scaling
          float viscosityFactor = 1.0 / (viscosity * 0.5 + 0.5);
          float physicsTime = time * viscosityFactor * 0.3;
          float densityFactor = 1.0 / (density * 0.3 + 0.7);
          float audioTime = time * (isPlaying > 0.5 ? 2.0 * densityFactor : 0.5);
          
          // Audio intensity
          float audioIntensity = volume + midLevel * 0.8 + highLevel * 0.6 + bassLevel * 0.4;
          vAudioIntensity = audioIntensity;
          
          // *** PUDDLE MODE - DRAMATIC FLATTENING ***
          vec3 workingPosition = position;
          if (puddleMode > 0.01) {
            // Dramatic Y-squashing and X/Z spreading
            float flatten = puddleMode * 3.5;
            workingPosition.y *= (1.0 - flatten * 0.9);
            
            // MUCH MORE DRAMATIC spread X/Z based on distance from center
            float radius = length(workingPosition.xz);
            float spread = 1.0 + puddleMode * radius * 4.0;
            workingPosition.xz *= spread;
            
            // Add ripple effects for puddle
            float ripple = sin(radius * 8.0 - time * 6.0) * puddleMode * 0.4;
            workingPosition.y += ripple;
            
            // Audio makes puddle splash
            if (isPlaying > 0.5) {
              float splash = sin(radius * 4.0 - audioTime * 8.0) * audioIntensity * puddleMode * 0.8;
              workingPosition.y += splash;
            }
          }
          
          // *** ENHANCED EFFECTS ***
          
          // *** NATURAL MERCURY FLOW ***
          
          // Base flow - GENTLE LIKE REAL LIQUID
          vec3 noisePos = workingPosition * noiseScale;
          float baseFlow = fbm(noisePos + physicsTime * 0.3) * noiseForce * 0.4; // Much gentler
          
          // Viscosity effects - smooth like real mercury
          if (viscosity > 1.0) {
            float smoothFlow1 = fbm(noisePos * 0.6 + physicsTime * 0.25) * 0.8; // Gentler
            float smoothFlow2 = fbm(noisePos * 0.9 + physicsTime * 0.35) * 0.6;
            baseFlow = mix(baseFlow, (smoothFlow1 + smoothFlow2), (viscosity - 1.0) * 0.5); // More subtle mixing
          }
          
          // Surface tension splitting - more natural, less constraining
          vec3 splitPos = workingPosition * (1.2 + split * 0.5); // Less aggressive scaling
          float splitNoise = fbm(splitPos + physicsTime * 0.4);
          float tensionThreshold = 0.5 + surfaceTension * 0.2; // Lower threshold, less constraining
          float naturalSplit = 0.0;
          if (splitNoise > tensionThreshold) {
            naturalSplit = (splitNoise - tensionThreshold) * split * (2.0 - surfaceTension * 0.6); // More natural flow
          }
          
          // Elasticity effects - subtle like real mercury
          float elasticMotion = 0.0;
          if (elasticity > 0.1) {
            float elasticPhase = time * (1.5 + elasticity * 3.0) + length(workingPosition) * 1.5; // Slower
            elasticMotion = sin(elasticPhase) * cos(elasticPhase * 0.5) * elasticity * 0.25; // Much gentler
            if (isPlaying > 0.5) {
              elasticMotion *= (1.0 + audioIntensity * 1.5); // Less reactive
            }
          }
          
          // Density effects
          float densityMultiplier = (3.0 - density) * 0.6; // Less dramatic
          
          // Liquid effects - gentle flow like real mercury
          float liquidFlow = sin(length(workingPosition) * 3.0 + audioTime * 0.8) * liquidity * 0.4 * densityMultiplier; // Gentler
          float goopyFlow = fbm(workingPosition * 2.8 + physicsTime * 0.8) * goopiness * 0.8; // Less intense
          
          // Audio deformation - NATURAL AND SMOOTH
          float audioDeformation = 0.0;
          if (isPlaying > 0.5) {
            // Gentle audio response like real liquid
            float totalAudioIntensity = volume * 0.2 + bassLevel * 0.3 + midLevel * 0.2 + highLevel * 0.1;
            audioDeformation = totalAudioIntensity * audioReactivity * 0.3 * densityMultiplier; // Much gentler
            
            // Smooth peaks without extreme reactions
            if (bassLevel > 0.6) {
              audioDeformation *= (1.0 + bassLevel * 0.5); // Gentle peak response
            }
          }
          
          // *** NATURAL FLUID EFFECTS ***
          
          // GENTLE SPLITTING - Less constraining surface tension
          float naturalSplitting = 0.0;
          if (splitIntensity > 0.01) {
            vec3 fracPos = workingPosition * (1.1 + splitIntensity * 0.6); // Less aggressive
            float fracNoise = fbm(fracPos + physicsTime * 0.6);
            float splitThreshold = 0.55 + surfaceTension * 0.15; // More permissive
            if (fracNoise > splitThreshold) {
              naturalSplitting = (fracNoise - splitThreshold) * splitIntensity * (1.8 - surfaceTension * 0.4); // Less constraining
              if (isPlaying > 0.5) {
                naturalSplitting *= (1.0 + bassLevel * 1.0 * densityMultiplier); // Gentle bass reaction
              }
            }
          }
          
          // FLOWING RIPPLES - Natural wave-like motion
          float ripples = 0.0;
          if (tentacleMode > 0.01) {
            vec3 ripplePos = workingPosition * 2.5; // Less aggressive scaling
            float rippleNoise = fbm(ripplePos + audioTime * 0.8);
            if (rippleNoise > 0.5) { // Lower threshold
              ripples = (rippleNoise - 0.5) * tentacleMode * 2.0; // More natural flow
              
              if (elasticity > 0.3) {
                float elasticRipple = sin(time * 2.5 + length(workingPosition) * 1.8) * elasticity * 0.25;
                ripples *= (1.0 + elasticRipple);
              }
              
              if (isPlaying > 0.5) {
                ripples *= (1.0 + midLevel * 1.2 * densityMultiplier); // Gentle mid response
              }
            }
          }
          
          // NATURAL MERGES - Flowing like real liquid
          float fluidMerges = 0.0;
          if (liquidMerge > 0.01) {
            vec3 flowPos = workingPosition * 2.2; // Less constraining
            float flowNoise = fbm(flowPos + physicsTime * 0.4);
            if (flowNoise > 0.5) { // More permissive threshold
              fluidMerges = (flowNoise - 0.5) * liquidMerge * density * 1.3; // Natural flowing
              
              if (viscosity > 1.0) {
                fluidMerges *= smoothstep(0.5, 0.75, flowNoise); // Gentler smoothing
              }
              
              if (isPlaying > 0.5) {
                fluidMerges *= (1.0 + volume * 1.0 * densityMultiplier);
              }
            }
          }
          
          // GENTLE BREAKUP - Natural mercury behavior without constraints
          float subtleBreakup = 0.0;
          if (shattered > 0.5 && isPlaying > 0.5) {
            vec3 beadPos = workingPosition * 5.0; // Less aggressive
            float beadNoise = fbm(beadPos + physicsTime * 1.2);
            float beadResistance = (surfaceTension + elasticity) * 0.3; // Less constraining
            float beadThreshold = 0.6 + beadResistance * 0.1; // More permissive
            if (beadNoise > beadThreshold && bassLevel > 0.3) { // Lower audio threshold
              subtleBreakup = (beadNoise - beadThreshold) * bassLevel * (1.3 - beadResistance * 0.2);
            }
          }
          
          // NATURAL SWIRL - Gentle fluid rotation
          float gentleSwirl = 0.0;
          if (vortex > 0.5) {
            float angle = atan(workingPosition.z, workingPosition.x) + physicsTime * (1.0 - viscosity * 0.25);
            float radius = length(workingPosition.xz);
            gentleSwirl = sin(angle * 1.8 + radius * 1.3) * midLevel * 0.7 * densityMultiplier; // More natural
          }
          
          // *** COMBINE ALL EFFECTS - NATURAL AND FLOWING ***
          float totalDeformation = 
            baseFlow * 2.5 +           // Much higher base flow for maximum freedom
            liquidFlow * 2.0 +         // Increased liquid flow significantly
            goopyFlow * 2.2 +          // Increased goop for extreme fluid feel
            naturalSplit * 1.2 +       // Increased splitting for more dramatic effects
            audioDeformation * 1.5 +   // Much higher audio response
            elasticMotion * 1.4 +      // Increased elastic response
            naturalSplitting * 0.8 +   // Increased splitting effects    
            ripples * 1.0 +            // Increased ripple effects
            fluidMerges * 1.2 +        // Increased merges for extreme flow
            subtleBreakup * 0.6 +      // Increased breakup for more freedom
            gentleSwirl * 1.0;         // Increased swirl effects
          
          vDeformationAmount = abs(totalDeformation);
          
          // Apply displacement with MAXIMUM FREEDOM - no boundaries!
          vec3 displacement = normal * totalDeformation * 2.0; // DOUBLED displacement for extreme deformation
          
          // Enhanced audio-reactive displacement
          if (isPlaying > 0.5) {
            float audioDisplacementBoost = audioIntensity * audioReactivity * 1.0; // Increased from 0.5
            displacement *= (1.0 + audioDisplacementBoost);
          }
          
          // COMPLETE FREEDOM - no elasticity constraints whatsoever
          if (elasticity > 0.1) {
            float freeElastic = sin(time * 3.0 + totalDeformation * 6.0) * elasticity * 0.3; // Much more dramatic
            displacement *= (1.0 + freeElastic);
          }
          
          // COMPLETELY FREE position - NO BOUNDARIES OR CONSTRAINTS!
          vec3 newPosition = workingPosition + displacement;
          
          // DOT MATRIX MODE support
          if (dotMatrix > 0.5) {
            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
            
            float pointSize = 20.0 + totalDeformation * 50.0;
            if (isPlaying > 0.5) {
              pointSize += audioIntensity * 80.0 * densityMultiplier;
            }
            gl_PointSize = clamp(pointSize / max(-mvPosition.z * 0.1, 1.0), 10.0, 150.0);
          } else {
            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
          }
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform float metallic;
        uniform vec3 color1;
        uniform vec3 color2;
        uniform vec3 color3;
        
        // Audio data uniforms
        uniform float volume;
        uniform float midLevel;
        uniform float highLevel;
        uniform float bassLevel;
        
        // Color flow uniforms
        uniform float colorFlow;
        uniform float colorShift1;
        uniform float colorShift2;
        uniform float colorShift3;
        
        // ENHANCED SURFACE CONTROLS
        uniform float chrome;
        uniform float pearl;
        uniform float holographic;
        uniform float glass;
        uniform float roughness;
        
        // VISUAL EFFECTS
        uniform float contrast;
        uniform float bloom;
        uniform float grain;
        uniform float grainSize;
        
        // MODES
        uniform float dotMatrix;
        uniform float wireframe;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        varying float vAudioIntensity;
        varying float vDeformationAmount;
        
        // Enhanced noise for effects
        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }
        
        float filmGrain(vec2 coord, float intensity, float size, float time) {
          vec2 scaledCoord = coord * size;
          float grain1 = hash(scaledCoord + vec2(sin(time * 0.1), cos(time * 0.13)) * 100.0);
          float grain2 = hash(scaledCoord * 1.7 + vec2(cos(time * 0.07), sin(time * 0.11)) * 150.0) * 0.6;
          return (grain1 + grain2) / 1.6 * intensity;
        }
        
        void main() {
          // DOT MATRIX MODE - enhanced magnetic balls
          if (dotMatrix > 0.5) {
            vec2 center = gl_PointCoord - 0.5;
            float dist = length(center);
            
            if (dist > 0.5) discard;
            
            float sphere = sqrt(1.0 - 4.0 * dist * dist);
            vec3 normal = normalize(vec3(center * 2.0, sphere));
            vec3 light = normalize(vec3(1.0, 1.0, 1.0));
            float NdotL = max(0.0, dot(normal, light));
            
            // Smooth flowing colors for droplets - gentle and natural
            float colorPhase1 = time * 0.6 + vWorldPosition.x * 0.2 + vAudioIntensity * 2.0; // Much slower
            float colorPhase2 = time * 0.5 + vWorldPosition.y * 0.15 + vAudioIntensity * 1.5;
            float colorPhase3 = time * 0.7 + vWorldPosition.z * 0.25 + vAudioIntensity * 2.5;
            
            vec3 ballColor = mix(color1, color2, sin(colorPhase1) * 0.5 + 0.5);
            ballColor = mix(ballColor, color3, sin(colorPhase2) * 0.5 + 0.5);
            ballColor *= (1.0 + sin(colorPhase3) * 0.15); // Much gentler variation
            
            float fresnel = pow(1.0 - sphere, 2.0);
            ballColor *= (1.0 + fresnel * metallic * 0.8);
            ballColor *= (0.8 + vAudioIntensity * 0.8);
            ballColor *= (0.4 + NdotL * 0.6);
            
            gl_FragColor = vec4(ballColor, 1.0);
            return;
          }
          
          // *** SMOOTH NATURAL COLOR FLOW - DISCONNECTED FROM BEATS ***
          
          vec3 viewDirection = normalize(-vViewPosition);
          vec3 normal = normalize(vNormal);
          float fresnel = pow(1.0 - max(0.0, dot(normal, viewDirection)), 1.2); // Even gentler
          
          // Create ultra-smooth flowing currents - COMPLETELY CALM
          vec3 flowPos = vWorldPosition * 0.15; // Even finer detail
          float gentleTime = time * 0.4; // VERY slow, disconnected from audio
          
          // Natural mercury currents - ULTRA SMOOTH AND ABSTRACT
          float current1 = sin(gentleTime * 0.3 + flowPos.x * 1.0) * 0.3 + 0.7; // Very gentle, centered high
          float current2 = sin(gentleTime * 0.25 + flowPos.y * 0.9) * 0.3 + 0.7;
          float current3 = sin(gentleTime * 0.28 + flowPos.z * 1.1) * 0.3 + 0.7;
          
          // Extremely gentle secondary ripples - barely perceptible
          float ripple1 = sin(gentleTime * 0.4 + length(flowPos.xy) * 1.5) * 0.08 + 0.92; // Tiny ripples
          float ripple2 = cos(gentleTime * 0.35 + length(flowPos.xz) * 1.6) * 0.08 + 0.92;
          float ripple3 = sin(gentleTime * 0.38 + length(flowPos.yz) * 1.4) * 0.08 + 0.92;
          
          // Combine currents with ultra-gentle ripples
          current1 *= ripple1;
          current2 *= ripple2;
          current3 *= ripple3;
          
          // *** TRI-COLOR ZONE SYSTEM - THREE DISTINCT MOVING AREAS ***
          
          // ABSTRACT COLOR MIXING - All three colors visible simultaneously
          vec3 flowingColor = color1 * current1 + color2 * current2 + color3 * current3;
          
          // Normalize to prevent oversaturation while keeping all colors visible
          float totalWeight = current1 + current2 + current3;
          flowingColor = flowingColor / totalWeight;
          
          // Add gentle inter-color blending zones
          vec3 blend12 = mix(color1, color2, smoothstep(0.3, 0.7, current1 + current2));
          vec3 blend23 = mix(color2, color3, smoothstep(0.3, 0.7, current2 + current3));
          vec3 blend31 = mix(color3, color1, smoothstep(0.3, 0.7, current3 + current1));
          
          // Combine main colors with blend zones for rich, complex color
          flowingColor = mix(flowingColor, 
            (blend12 + blend23 + blend31) / 3.0, 
            0.4); // 40% blend zones, 60% pure colors
          
          // Extremely gentle natural variance - like slow mercury surface waves
          float variance = sin(gentleTime * 0.15 + vWorldPosition.x * 0.8) * 
                          cos(gentleTime * 0.12 + vWorldPosition.y * 0.9) * 
                          sin(gentleTime * 0.18 + vWorldPosition.z * 0.7) * 0.04 + 1.0; // Tiny variation
          
          flowingColor *= variance;
          
          // Ultra-gentle breathing - like slow mercury breathing
          float breathingPhase = time * 0.08; // VERY slow breathing
          float breathingIntensity = sin(breathingPhase) * 0.03 + 0.97; // Barely visible
          
          // Apply calm, stable base color
          vec3 baseColor = flowingColor * breathingIntensity;
          
          // Keep colors pure and natural
          baseColor = clamp(baseColor, vec3(0.0), vec3(1.0));
          
          // *** SURFACE EFFECTS - ONLY WHEN ENABLED, NO WHITE CONTAMINATION ***
          
          // CHROME EFFECT - Subtle metallic reflection
          if (chrome > 0.01) {
            float chromeAmount = fresnel * chrome * 0.6; // Much more subtle
            baseColor = mix(baseColor, baseColor * (1.0 + chromeAmount), chrome * 0.4);
          }
          
          // PEARL IRIDESCENCE - Gentle color shifting  
          if (pearl > 0.01) {
            float pearlPhase = fresnel * 8.0 + time * 2.0;
            vec3 pearlShift = vec3(
              sin(pearlPhase) * 0.3 + 1.0,
              sin(pearlPhase + 2.1) * 0.3 + 1.0, 
              sin(pearlPhase + 4.2) * 0.3 + 1.0
            );
            baseColor = mix(baseColor, baseColor * pearlShift, pearl * fresnel * 0.3);
          }
          
          // HOLOGRAPHIC EFFECT - Gentle rainbow shift
          if (holographic > 0.01) {
            float holoPhase = fresnel * 10.0 + time * 3.0;
            vec3 holoShift = vec3(
              sin(holoPhase) * 0.2 + 1.0,
              sin(holoPhase + 2.1) * 0.2 + 1.0,
              sin(holoPhase + 4.2) * 0.2 + 1.0
            );
            baseColor = mix(baseColor, baseColor * holoShift, holographic * fresnel * 0.4);
          }
          
          // GLASS EFFECT - Subtle transparency-like effect
          if (glass > 0.01) {
            float glassEffect = fresnel * glass * 0.3;
            baseColor = mix(baseColor, baseColor * (1.0 + glassEffect), glass * 0.3);
          }
          
          // ROUGHNESS EFFECT - Surface texture, not color change
          if (roughness > 0.01) {
            float roughPattern = sin(vWorldPosition.x * 30.0) * sin(vWorldPosition.y * 29.0) * sin(vWorldPosition.z * 31.0);
            baseColor = mix(baseColor, baseColor * (1.0 + roughPattern * 0.1), roughness * 0.5);
          }
          
          // METALLIC REFLECTION - Enhance existing colors, don't add white
          if (metallic > 0.01) {
            vec3 metallicColor = baseColor * (1.0 + fresnel * metallic * 0.4);
            baseColor = mix(baseColor, metallicColor, metallic * 0.5);
          }
          
          // *** VISUAL EFFECTS ***
          
          // FILM GRAIN
          if (grain > 0.001) {
            float grainEffect = filmGrain(gl_FragCoord.xy / 600.0, grain, grainSize, time);
            baseColor *= (1.0 + grainEffect * 0.3);
          }
          
          // CONTRAST
          if (contrast != 1.0) {
            vec3 midTone = vec3(0.5);
            baseColor = mix(midTone, baseColor, contrast);
          }
          
          // BLOOM GLOW
          if (bloom > 0.001) {
            float luminance = dot(baseColor, vec3(0.299, 0.587, 0.114));
            float bloomThreshold = 0.4;
            float bloomAmount = max(0.0, luminance - bloomThreshold) * bloom;
            baseColor *= (1.0 + bloomAmount * 4.0);
          }
          
          // WIREFRAME MODE
          if (wireframe > 0.5) {
            vec3 wireColor = baseColor * (1.5 + vAudioIntensity * 1.2);
            float edgeGlow = pow(fresnel, 0.2) * 3.0;
            wireColor += edgeGlow * baseColor * 0.8;
            
            float pulse = sin(time * 15.0 + vAudioIntensity * 25.0) * 0.4 + 0.8;
            wireColor *= pulse;
            
            gl_FragColor = vec4(wireColor, 1.0);
            return;
          }
          
          // Deformation highlights - Keep colors natural
          if (vDeformationAmount > 0.05) {
            vec3 deformGlow = baseColor * vDeformationAmount * 0.3; // Much more subtle
            baseColor = mix(baseColor, baseColor + deformGlow, 0.5);
          }
          
          // NO MINIMUM BRIGHTNESS - Keep pure colors!
          gl_FragColor = vec4(baseColor, 1.0);
        }
      `,
      wireframe: false,
      transparent: false,
    })
  }, [])

  // *** COMPLETE UNIFORMS UPDATE - ALL CONTROLS NOW WORKING! ***
  useFrame((state) => {
    if (!meshRef.current) return
    
    const time = state.clock.elapsedTime
    const mat = (meshRef.current as any).material as THREE.ShaderMaterial
    
    if (mat && mat.uniforms) {
      mat.uniforms.time.value = time
      mat.uniforms.isPlaying.value = isPlaying && audioSrc ? 1.0 : 0.0
      
      // Audio data
      mat.uniforms.volume.value = safeAudioData.volume
      mat.uniforms.midLevel.value = safeAudioData.midLevel
      mat.uniforms.highLevel.value = safeAudioData.highLevel
      mat.uniforms.bassLevel.value = safeAudioData.bassLevel
      
      // ENHANCED AUDIO-DRIVEN CONTROLS - Physical properties auto-connected to audio
      const audioReactivity = controls.audioReactivity || 6.0
      const volumeIntensity = safeAudioData.volume
      const bassIntensity = safeAudioData.bassLevel
      const midIntensity = safeAudioData.midLevel
      
      // Auto-connect flow intensity to audio with user control as multiplier
      const audioFlowIntensity = (controls.noiseForce || 1.5) * (1.0 + volumeIntensity * audioReactivity * 0.3)
      
      // Auto-connect physical properties to audio with user controls as deformation intensity multipliers
      const audioViscosity = (controls.viscosity || 0.5) * (1.0 + bassIntensity * audioReactivity * 0.2)
      const audioSurfaceTension = (controls.surfaceTension || 0.7) * (1.0 + midIntensity * audioReactivity * 0.15)
      const audioDensity = (controls.density || 1.0) * (1.0 + volumeIntensity * audioReactivity * 0.25)
      const audioElasticity = (controls.elasticity || 0.5) * (1.0 + (bassIntensity + midIntensity) * audioReactivity * 0.3)
      
      // CORE CONTROLS - now audio-enhanced
      mat.uniforms.noiseScale.value = controls.noiseScale || 2.2
      mat.uniforms.noiseForce.value = audioFlowIntensity // Audio-driven flow intensity
      mat.uniforms.goopiness.value = controls.goopiness || 1.5
      mat.uniforms.liquidity.value = controls.liquidity || 2.0
      mat.uniforms.split.value = controls.split || 0.8
      mat.uniforms.metallic.value = controls.metallic || 0.7
      
      // COLORS
      mat.uniforms.color1.value.set(controls.color1 || '#00f2ff')
      mat.uniforms.color2.value.set(controls.color2 || '#ff00a8')
      mat.uniforms.color3.value.set(controls.color3 || '#7000ff')
      
      // AUDIO REACTIVITY
      mat.uniforms.audioReactivity.value = audioReactivity
      
      // *** AUDIO-DRIVEN PHYSICAL PROPERTIES ***
      mat.uniforms.viscosity.value = audioViscosity
      mat.uniforms.surfaceTension.value = audioSurfaceTension
      mat.uniforms.density.value = audioDensity
      mat.uniforms.elasticity.value = audioElasticity
      
      // *** PUDDLE MODE - NOW WORKING! ***
      mat.uniforms.puddleMode.value = controls.puddleMode || 0.0
      
      // DRAMATIC EFFECTS
      mat.uniforms.splitIntensity.value = controls.splitIntensity || 0
      mat.uniforms.tentacleMode.value = controls.tentacleMode || 0
      mat.uniforms.liquidMerge.value = controls.liquidMerge || 0
      mat.uniforms.shattered.value = controls.shattered ? 1.0 : 0.0
      mat.uniforms.vortex.value = controls.vortex ? 1.0 : 0.0
      
      // ENHANCED SURFACE CONTROLS
      mat.uniforms.chrome.value = controls.chrome || 0
      mat.uniforms.pearl.value = controls.pearl || 0
      mat.uniforms.holographic.value = controls.holographic || 0
      mat.uniforms.glass.value = controls.glass || 0
      mat.uniforms.roughness.value = controls.roughness || 0
      
      // VISUAL EFFECTS
      mat.uniforms.contrast.value = controls.contrast || 1.0
      mat.uniforms.bloom.value = controls.bloom || 0
      mat.uniforms.grain.value = controls.grain || 0
      mat.uniforms.grainSize.value = controls.grainSize || 1.0
      
      // MODES
      mat.uniforms.dotMatrix.value = (controls.dotMatrix || forceDotMatrix) ? 1.0 : 0.0
      mat.uniforms.wireframe.value = controls.wireframe ? 1.0 : 0.0
      
      // COLOR FLOW VALUES
      mat.uniforms.colorFlow.value = controls.colorFlow || 0.0
      mat.uniforms.colorShift1.value = controls.colorShift1 || 0.0
      mat.uniforms.colorShift2.value = controls.colorShift2 || 0.0
      mat.uniforms.colorShift3.value = controls.colorShift3 || 0.0
      
      mat.wireframe = controls.wireframe && !controls.dotMatrix && !forceDotMatrix
    }
    
    // Gentle rotation for visual interest - like floating in space
    meshRef.current.rotation.y += 0.002 // Reduced from 0.005
    meshRef.current.rotation.x += 0.001 // Reduced from 0.002
    meshRef.current.rotation.z += 0.0005 // Reduced from 0.001
  })

  // Enhanced geometry with more shapes and higher detail
  const geometry = useMemo(() => {
    const segments = (controls.dotMatrix || forceDotMatrix) ? 256 : 120 // Much higher detail
    const radius = 1.5 * scale
    
    try {
      switch (blobShape) {
        case 'cube':
          return <boxGeometry args={[2 * scale, 2 * scale, 2 * scale, 32, 32, 32]} /> // Much higher subdivision
        case 'torus':
          return <torusGeometry args={[1.2 * scale, 0.6 * scale, 32, segments]} />
        case 'icosahedron':
          return <icosahedronGeometry args={[radius, 6]} /> // Higher subdivision for smoother surface
        case 'octahedron':
          return <octahedronGeometry args={[radius, 5]} />
        case 'dodecahedron':
          return <dodecahedronGeometry args={[radius, 4]} />
        case 'tetrahedron':
          return <tetrahedronGeometry args={[radius, 4]} />
        case 'cylinder':
          return <cylinderGeometry args={[radius, radius, radius * 2, segments, 20]} /> // Radial and height segments
        case 'cone':
          return <coneGeometry args={[radius, radius * 2, segments, 15]} />
        case 'torusKnot':
          return <torusKnotGeometry args={[radius * 0.8, radius * 0.3, segments, 24]} />
        case 'ring':
          return <ringGeometry args={[radius * 0.5, radius, 16, segments]} />
        case 'capsule':
          return <capsuleGeometry args={[radius * 0.6, radius * 1.2, 12, segments/2]} />
        case 'pyramid':
          return <coneGeometry args={[radius, radius * 1.5, 8]} /> // More faces for smoother pyramid
        case 'prism':
          return <cylinderGeometry args={[radius, radius, radius * 1.5, 8, 10]} />
        case 'sphere':
        default:
          return <sphereGeometry args={[radius, segments, segments/2]} /> // Much higher detail sphere
      }
    } catch (error) {
      console.warn('Geometry creation error, falling back to high-detail sphere:', error)
      return <sphereGeometry args={[radius, 80, 40]} /> // Higher detail fallback
    }
  }, [blobShape, scale, controls.dotMatrix, forceDotMatrix])

  // Handle dot matrix mode vs regular mesh
  if (controls.dotMatrix || forceDotMatrix) {
    return (
      <points ref={meshRef as any} position={position}>
      {geometry}
      <primitive object={material} />
    </points>
    )
  }

  return (
    <mesh ref={meshRef as any} position={position}>
      {geometry}
      <primitive object={material} />
    </mesh>
  )
}

// Enhanced Magnetic Droplet System - Dramatic with shape changes and 3D goop connections
function MagneticDroplets({ backgroundIntensity = 0.15 }: { backgroundIntensity?: number }) {
  const { audioData, isPlaying, controls } = useAudio()
  const groupRef = useRef<THREE.Group>(null)
  const dropletRefs = useRef<THREE.Mesh[]>([])
  const connectionRefs = useRef<THREE.Mesh[]>([]) // Changed from Line to Mesh for 3D tubes
  const lastBeatTimeRef = useRef(0)
  const lastConnectionEventRef = useRef(0)
  const formationStateRef = useRef<'together' | 'breaking' | 'scattered' | 'reforming' | 'dramatic'>('together')
  const breakStartTimeRef = useRef(0)
  
  const dropletPositions = useRef<Array<{
    formationPos: [number, number, number]
    scatterPos: [number, number, number]
    currentPos: [number, number, number]
    velocity: [number, number, number]
    phase: number
    connections: number[]
    energy: number
    shape: 'sphere' | 'cube' | 'tetrahedron' | 'octahedron'
    targetShape: 'sphere' | 'cube' | 'tetrahedron' | 'octahedron'
    shapeTransition: number
    scale: [number, number, number]
    rotation: [number, number, number]
    rotationSpeed: [number, number, number]
    dramIntensity: number
    lastBeatResponse: number
  }>>([])
  
  // Enhanced droplet controls
  const dropletCount = Math.min(Math.floor((controls.dropletCount || 8) * (0.6 + backgroundIntensity * 0.4)), 15)
  const dropletSize = (controls.dropletSize || 0.8) * 0.8
  const dropletSpeed = (controls.dropletSpeed || 0.8) * 2.0 // More dramatic movement
  const dropletSpread = (controls.dropletSpread || 100) * 1.5 // Increased multiplier and fixed default
  const dropletMagnetic = (controls.dropletMagnetic || 0.3) * 2.5 // Much stronger magnetic forces
  const dramIntensity = controls.dropletDramIntensity || 0.7
  const allowShapeChange = controls.dropletShapeChange !== false
  const connectionThickness = controls.dropletConnectionThickness || 0.5
  const connectionOpacity = controls.dropletConnectionOpacity || 0.6
  const rotationSpeed = controls.dropletRotationSpeed || 1.0
  const scaleReactivity = controls.dropletScaleReactivity || 0.8
  
  // *** NEW ENHANCED ABSTRACT DROPLET CONTROLS ***
  const dropletBrightness = controls.dropletBrightness || 1.5
  const dropletGlow = controls.dropletGlow || 0.8
  const dropletMetallic = controls.dropletMetallic || 0.9
  const dropletRoughness = controls.dropletRoughness || 0.1
  const dropletIridescence = controls.dropletIridescence || 0.3
  const dropletPulse = controls.dropletPulse || 0.5
  const dropletFluid = controls.dropletFluid || 0.7
  
  // Initialize enhanced droplet positions
  if (dropletPositions.current.length !== dropletCount) {
    dropletPositions.current = []
    // Make center radius responsive to spread setting - MUCH more dramatic
    const centerRadius = Math.max(8, dropletSpread * 0.3) // Now responsive to droplet spread!
    
    for (let i = 0; i < dropletCount; i++) {
      const angle = (i / dropletCount) * Math.PI * 2
      const radius = centerRadius + Math.random() * (dropletSpread * 0.15) // Vary radius based on spread
      const height = (Math.random() - 0.5) * (dropletSpread * 0.2) // Height also spread-dependent
      
      const shapes: Array<'sphere' | 'cube' | 'tetrahedron' | 'octahedron'> = ['sphere', 'cube', 'tetrahedron', 'octahedron']
      const initialShape = shapes[Math.floor(Math.random() * shapes.length)]
      
      dropletPositions.current.push({
        formationPos: [Math.cos(angle) * radius, height, Math.sin(angle) * radius],
        scatterPos: [(Math.random() - 0.5) * dropletSpread * 1.5, (Math.random() - 0.5) * dropletSpread * 1.0, (Math.random() - 0.5) * dropletSpread * 1.5], // Increased scatter
        currentPos: [Math.cos(angle) * radius, height, Math.sin(angle) * radius],
        velocity: [0, 0, 0],
        phase: Math.random() * Math.PI * 2,
        connections: [],
        energy: 0.5 + Math.random() * 0.5,
        shape: initialShape,
        targetShape: initialShape,
        shapeTransition: 0.0,
        scale: [1, 1, 1],
        rotation: [Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2],
        rotationSpeed: [(Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.2],
        dramIntensity: Math.random() * 0.5 + 0.5,
        lastBeatResponse: 0
      })
    }
  }
  
  useFrame((state) => {
    if (!groupRef.current || !isPlaying) return
    
    const time = state.clock.elapsedTime
    const audioIntensity = audioData ? audioData.volume : 0
    const bassLevel = audioData ? audioData.bassLevel : 0
    const midLevel = audioData ? audioData.midLevel : 0
    const highLevel = audioData ? audioData.highLevel : 0
    const beatDetected = audioData ? audioData.beatDetected : false
    
    // DRAMATIC EVENT-DRIVEN STATE CHANGES
    if (beatDetected && time - lastBeatTimeRef.current > 1.0) {
      if (formationStateRef.current === 'together' && bassLevel > 0.5) {
        formationStateRef.current = 'dramatic'
        breakStartTimeRef.current = time
        lastBeatTimeRef.current = time
        
        // Dramatic scatter with more force
        dropletPositions.current.forEach((data, i) => {
          const dramaticForce = 2.0 + bassLevel * 4.0 // Increased base force and bass multiplier
          data.scatterPos = [
            (Math.random() - 0.5) * dropletSpread * dramaticForce * 1.5, // Added extra multiplier
            (Math.random() - 0.5) * dropletSpread * 1.2, // Increased Y spread
            (Math.random() - 0.5) * dropletSpread * dramaticForce * 1.5 // Added extra multiplier
          ]
          
          // Trigger shape changes on beats
          const shapes: Array<'sphere' | 'cube' | 'tetrahedron' | 'octahedron'> = ['sphere', 'cube', 'tetrahedron', 'octahedron']
          if (allowShapeChange) {
            data.targetShape = shapes[Math.floor(Math.random() * shapes.length)]
          }
          data.lastBeatResponse = time
        })
      }
    }
    
    // Connection events on strong audio
    if ((beatDetected && bassLevel > 0.7) || (midLevel > 0.6 && time - lastConnectionEventRef.current > 0.5)) {
      lastConnectionEventRef.current = time
    }
    
    const timeSinceBreak = time - breakStartTimeRef.current
    switch (formationStateRef.current) {
      case 'dramatic': if (timeSinceBreak > 1.5) formationStateRef.current = 'scattered'; break
      case 'scattered': if (timeSinceBreak > 5.0) formationStateRef.current = 'reforming'; break
      case 'reforming': if (timeSinceBreak > 8.0) formationStateRef.current = 'together'; break
    }
    
    // Update droplets with dramatic behavior + MERCURY PHYSICS
    dropletPositions.current.forEach((data, i) => {
      let targetPos = data.formationPos
      let lerpSpeed = 0.03 * dropletSpeed
      
      // Apply mercury physics controls to droplet behavior
      const viscosityEffect = controls.viscosity || 0.6 // Affects movement smoothness
      const surfaceTensionEffect = controls.surfaceTension || 0.5 // Affects cohesion
      const densityEffect = controls.density || 0.6 // Affects weight/momentum
      const elasticityEffect = controls.elasticity || 0.6 // Affects bounce/collision
      const puddleModeEffect = controls.puddleMode || 0.0 // Affects flattening
      
      // Dramatic movement based on state with physics modifications
      switch (formationStateRef.current) {
        case 'dramatic':
          targetPos = data.scatterPos
          lerpSpeed = 0.15 * (1 + bassLevel * 2) * (1.0 / viscosityEffect) // Higher viscosity = slower movement
          break
        case 'scattered':
          targetPos = data.scatterPos
          lerpSpeed = 0.02 * (1.0 / viscosityEffect)
          break
        case 'reforming':
          targetPos = data.formationPos
          lerpSpeed = 0.08 * dropletSpeed * surfaceTensionEffect // Surface tension helps reformation
          break
      }
      
      // Enhanced floating motion with physics-based behavior
      const physicsFloat = audioIntensity * 2.0 * data.dramIntensity * dramIntensity * (1.0 / densityEffect) // Density affects responsiveness
      const floatOffset = [
        Math.sin(time * 0.4 * viscosityEffect + data.phase) * (1.5 + physicsFloat), // Viscosity affects oscillation speed
        Math.cos(time * 0.3 * viscosityEffect + data.phase) * (1.0 + physicsFloat * 0.6),
        Math.sin(time * 0.35 * viscosityEffect + data.phase) * (1.5 + physicsFloat)
      ]
      
      // Apply puddle mode flattening to droplets
      if (puddleModeEffect > 0.01) {
        floatOffset[1] *= (1.0 - puddleModeEffect * 0.8) // Flatten Y movement
        // Spread X/Z movement for puddle effect
        floatOffset[0] *= (1.0 + puddleModeEffect * 0.5)
        floatOffset[2] *= (1.0 + puddleModeEffect * 0.5)
      }
      
      // Mercury-physics magnetic forces with surface tension
      let magneticX = 0, magneticY = 0, magneticZ = 0
      data.connections = []
      
      if (dropletMagnetic > 0.1) {
        dropletPositions.current.forEach((other, j) => {
          if (i !== j) {
            const dx = other.currentPos[0] - data.currentPos[0]
            const dy = other.currentPos[1] - data.currentPos[1]
            const dz = other.currentPos[2] - data.currentPos[2]
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz)
            
            // Surface tension affects connection threshold - higher surface tension = stronger cohesion
            const connectionThreshold = Math.max(8, dropletSpread * 0.15) + audioIntensity * 6 + surfaceTensionEffect * 8
            if (distance < connectionThreshold) {
              data.connections.push(j)
              
              if (distance > 1.0) { // Closer for mercury-like behavior
                const force = dropletMagnetic * surfaceTensionEffect * 0.08 / (distance * distance) // Surface tension enhances magnetic force
                const audioBoost = 1.0 + (bassLevel + midLevel) * 1.2
                magneticX += dx * force * audioBoost
                magneticY += dy * force * audioBoost
                magneticZ += dz * force * audioBoost
              } else {
                // Very close droplets should merge behavior (influenced by surface tension)
                const mergeForce = surfaceTensionEffect * 0.1
                magneticX += dx * mergeForce
                magneticY += dy * mergeForce
                magneticZ += dz * mergeForce
              }
            }
          }
        })
      }
      
      // Mercury-physics energy and scale changes with elasticity
      const beatResponse = time - data.lastBeatResponse < 0.5 ? 1.0 - (time - data.lastBeatResponse) * 2.0 : 0.0
      data.energy = 0.4 + audioIntensity * 0.8 + midLevel * 0.6 + beatResponse * 0.5
      
      // Physics-based scale changes with elasticity and surface tension
      const physicsScaleBase = 0.8 + data.energy * 0.6 * scaleReactivity + beatResponse * 0.4 * scaleReactivity
      const elasticScale = 1.0 + Math.sin(time * 3.0 + data.phase) * elasticityEffect * 0.15 // Elastic breathing
      const tensionScale = 1.0 - surfaceTensionEffect * 0.1 // Higher surface tension = slightly smaller (more cohesive)
      const scaleMultiplier = physicsScaleBase * elasticScale * tensionScale
      
      // Apply puddle mode scaling
      if (puddleModeEffect > 0.01) {
        data.scale = [
          scaleMultiplier * (1.0 + puddleModeEffect * 0.3), // Wider in X
          scaleMultiplier * (1.0 - puddleModeEffect * 0.6), // Flatter in Y
          scaleMultiplier * (1.0 + puddleModeEffect * 0.3)  // Wider in Z
        ]
      } else {
        data.scale = [scaleMultiplier, scaleMultiplier, scaleMultiplier]
      }
      
      // Shape morphing with physics influence
      if (data.shape !== data.targetShape && allowShapeChange) {
        data.shapeTransition += 0.05 * (1.0 / viscosityEffect) // Viscosity affects morphing speed
        if (data.shapeTransition >= 1.0) {
          data.shape = data.targetShape
          data.shapeTransition = 0.0
        }
      }
      
      // Update position with mercury physics momentum
      const finalTargetX = targetPos[0] + floatOffset[0] + magneticX * 25 * dramIntensity * surfaceTensionEffect
      const finalTargetY = targetPos[1] + floatOffset[1] + magneticY * 25 * dramIntensity * surfaceTensionEffect
      const finalTargetZ = targetPos[2] + floatOffset[2] + magneticZ * 25 * dramIntensity * surfaceTensionEffect
      
      // Enhanced physics with density and elasticity
      const physicsDamping = 0.88 - audioIntensity * 0.1 * dramIntensity + viscosityEffect * 0.05 // Viscosity increases damping
      const momentumFactor = densityEffect * 0.3 // Density affects momentum
      
      data.velocity[0] += (finalTargetX - data.currentPos[0]) * lerpSpeed * momentumFactor
      data.velocity[1] += (finalTargetY - data.currentPos[1]) * lerpSpeed * momentumFactor
      data.velocity[2] += (finalTargetZ - data.currentPos[2]) * lerpSpeed * momentumFactor
      
      // Apply elasticity for bounce effects when energy is high
      if (beatResponse > 0.3 && elasticityEffect > 0.3) {
        const bounceForce = elasticityEffect * beatResponse * 0.2
        data.velocity[0] += (Math.random() - 0.5) * bounceForce
        data.velocity[1] += Math.abs(Math.random()) * bounceForce * 0.5 // Mostly upward bounce
        data.velocity[2] += (Math.random() - 0.5) * bounceForce
      }
      
      data.velocity[0] *= physicsDamping
      data.velocity[1] *= physicsDamping
      data.velocity[2] *= physicsDamping
      
      data.currentPos[0] += data.velocity[0]
      data.currentPos[1] += data.velocity[1]
      data.currentPos[2] += data.velocity[2]
      
      // Enhanced rotation with physics - viscosity slows rotation
      const audioRotationBoost = 1.0 + audioIntensity * 3.0 * rotationSpeed * (1.0 / viscosityEffect)
      data.rotation[0] += data.rotationSpeed[0] * audioRotationBoost
      data.rotation[1] += data.rotationSpeed[1] * audioRotationBoost
      data.rotation[2] += data.rotationSpeed[2] * audioRotationBoost
      
      // Update mesh
      const mesh = dropletRefs.current[i]
      if (mesh) {
        mesh.position.set(data.currentPos[0], data.currentPos[1], data.currentPos[2])
        mesh.scale.set(data.scale[0] * dropletSize, data.scale[1] * dropletSize, data.scale[2] * dropletSize)
        mesh.rotation.set(data.rotation[0], data.rotation[1], data.rotation[2])
        
        // Enhanced material updates - CALM COLORS, REACTIVE MOVEMENT
        const material = mesh.material as THREE.MeshStandardMaterial
        material.emissiveIntensity = data.energy * dropletGlow * dropletBrightness
        material.roughness = dropletRoughness * (1.0 - data.energy * 0.3)
        material.metalness = dropletMetallic + data.energy * 0.1
        
        // Gentle pulsing brightness - NO beat reactivity for colors
        const gentlePulse = 1.0 + Math.sin(time * 0.8 + i * 0.3) * 0.1 * dropletPulse // Slow, natural pulse
        
        // Gentle iridescent color shifting - SLOW AND NATURAL
        if (dropletIridescence > 0.01) {
          const iridPhase = time * 0.6 + i * 0.8 // Much slower color shifts
          const hue = (Math.sin(iridPhase) * 0.5 + 0.5) * 360
          const iridColor = new THREE.Color().setHSL(hue / 360, 0.6, 0.7) // Gentler saturation
          
          material.color = new THREE.Color(controls.color2 || '#ff00a8').lerp(iridColor, dropletIridescence * 0.7) // Reduced blend
        } else {
          material.color.set(controls.color2 || '#ff00a8')
        }
        
        // Apply gentle brightness - no beat flashing
        material.color.multiplyScalar(dropletBrightness * gentlePulse)
        material.emissive.set(controls.color3 || '#7000ff').multiplyScalar(dropletGlow * gentlePulse)
      }
    })
    
    // Create 3D GOOP CONNECTIONS instead of lines
    connectionRefs.current.forEach(tube => {
      if (tube.parent) {
        tube.parent.remove(tube)
      }
    })
    connectionRefs.current = []
    
    if (groupRef.current) {
      const connectionEventBoost = time - lastConnectionEventRef.current < 1.0 ? 
        1.0 - (time - lastConnectionEventRef.current) : 0.3
      
      dropletPositions.current.forEach((data, i) => {
        data.connections.forEach(j => {
          if (j > i) { // Avoid duplicate connections
            const other = dropletPositions.current[j]
            const distance = Math.sqrt(
              Math.pow(data.currentPos[0] - other.currentPos[0], 2) +
              Math.pow(data.currentPos[1] - other.currentPos[1], 2) +
              Math.pow(data.currentPos[2] - other.currentPos[2], 2)
            )
            
            if (distance < 20) {
              // Create 3D tube geometry for goop connection
              const tubeGeometry = new THREE.CylinderGeometry(
                0.1 * connectionThickness + connectionEventBoost * 0.3 * connectionThickness, // Start radius
                0.1 * connectionThickness + connectionEventBoost * 0.3 * connectionThickness, // End radius  
                distance, // Height
                8, // Radial segments
                1 // Height segments
              )
              
              const tubeMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(controls.color1 || '#00f2ff').multiplyScalar(dropletBrightness),
                opacity: Math.max(0.2, (1.0 - distance / 20) * 0.8 * connectionEventBoost * connectionOpacity),
                transparent: true,
                emissive: new THREE.Color(controls.color2 || '#ff00a8').multiplyScalar(dropletGlow * dropletBrightness),
                emissiveIntensity: connectionEventBoost * 0.6 * dropletBrightness,
                metalness: dropletMetallic,
                roughness: dropletRoughness
              })
              
              const tube = new THREE.Mesh(tubeGeometry, tubeMaterial)
              
              // Position and orient the tube
              const midPoint = [
                (data.currentPos[0] + other.currentPos[0]) / 2,
                (data.currentPos[1] + other.currentPos[1]) / 2,
                (data.currentPos[2] + other.currentPos[2]) / 2
              ]
              
              tube.position.set(midPoint[0], midPoint[1], midPoint[2])
              
              // Orient tube towards connection
              const direction = new THREE.Vector3(
                other.currentPos[0] - data.currentPos[0],
                other.currentPos[1] - data.currentPos[1], 
                other.currentPos[2] - data.currentPos[2]
              ).normalize()
              
              tube.lookAt(
                midPoint[0] + direction.x,
                midPoint[1] + direction.y,
                midPoint[2] + direction.z
              )
              tube.rotateX(Math.PI / 2) // Align with cylinder axis
              
              if (groupRef.current) {
                groupRef.current.add(tube)
              }
              connectionRefs.current.push(tube)
            }
          }
        })
      })
    }
  })
  
  if (!isPlaying || backgroundIntensity < 0.01) return null
  
  // Create enhanced droplet meshes with shape variations - MORE LIQUID-LIKE
  const droplets = dropletPositions.current.map((data, i) => {
    let geometry
    
    // FLUID LIQUID-LIKE GEOMETRY with more organic shapes
    switch (data.shape) {
      case 'cube':
        // Softer, more rounded cube
        geometry = <sphereGeometry args={[0.7, 16, 16]} />
        break
      case 'tetrahedron':
        // Droplet-like tetrahedron
        geometry = <sphereGeometry args={[0.6, 12, 8]} />
        break
      case 'octahedron':
        // Liquid octahedron
        geometry = <sphereGeometry args={[0.65, 14, 10]} />
        break
      default: // sphere - most liquid-like
        // Perfect mercury droplet
        geometry = <sphereGeometry args={[0.6, 20, 20]} />
    }
    
    return (
      <mesh
        key={i}
        ref={(ref) => {
          if (ref) dropletRefs.current[i] = ref
        }}
        position={data.currentPos as [number, number, number]}
      >
        {geometry}
        <meshStandardMaterial
          color={new THREE.Color(controls.color2 || '#ff00a8').multiplyScalar(dropletBrightness)}
          metalness={dropletMetallic}
          roughness={dropletRoughness}
          emissive={new THREE.Color(controls.color3 || '#7000ff').multiplyScalar(dropletGlow)}
          emissiveIntensity={dropletGlow * dropletBrightness}
          transparent={true}
          opacity={0.95} // Slightly more opaque for better liquid feel
        />
      </mesh>
    )
  })
  
  return (
    <group ref={groupRef}>
      {droplets}
    </group>
  )
}

export function AudioVisualizer() {
  const { audioSrc, isPlaying, audioData, controls } = useAudio()
  
  // Safe audio data
  const safeAudioData = audioData || {
    volume: 0,
    peakVolume: 0,
    averageVolume: 0,
    dbLevel: -60,
    bassLevel: 0,
    midLevel: 0,
    highLevel: 0,
    beatDetected: false,
    tempo: 0,
    beatStrength: 0,
    halfTempoBeat: false,
    beatCount: 0,
  }

  return (
    <div className="w-full h-full relative bg-black">
      {/* Auto Animation Sequence */}
      <AnimationSequence />
      
      <Canvas
        camera={{ 
          position: [0, 0, 15],
          fov: 50,
          far: 1000,
          near: 0.1 
        }}
        gl={{ 
          antialias: true, 
          alpha: true
        }}
        style={{ width: '100%', height: '100%' }}
      >
        {/* ENHANCED LIGHTING */}
        <ambientLight intensity={0.8} />
        <pointLight position={[10, 10, 10]} intensity={1.2} />
        <pointLight position={[-10, -10, -10]} intensity={1.0} />
        <pointLight position={[0, 10, -10]} intensity={0.8} />
        <pointLight position={[0, -10, 10]} intensity={0.6} />
        
        {/* DYNAMIC EVOLVING BACKGROUND */}
        <MagneticDroplets backgroundIntensity={controls.backgroundIntensity || 0.15} />
        
        {/* MAIN MERCURY BLOB */}
        <MercuryBlob position={[0, 0, 0] as [number, number, number]} scale={1.0} blobId={0} />
        
        {/* SMALL BASS OBJECTS */}
        {isPlaying && audioSrc && (
          <BassSpheres audioData={safeAudioData} />
        )}
        
        <OrbitControls 
          enableZoom={true}
          enablePan={true}
          enableRotate={true}
          autoRotate={false}
          minDistance={2}     // Closer zoom allowed
          maxDistance={300}   // Further zoom allowed
          target={[0, 0, 0]}
          zoomSpeed={1.5}     // Faster zoom for better control
          rotateSpeed={0.6}   // Slightly faster rotation
          panSpeed={1.0}      // Good pan speed
          enableDamping={true}
          dampingFactor={0.08} // Slightly snappier damping
          mouseButtons={{
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY, // Ensure middle mouse zoom works
            RIGHT: THREE.MOUSE.PAN
          }}
          touches={{
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN // Touch zoom and pan
          }}
        />
      </Canvas>
      
      {!audioSrc && (
        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
          <div className="text-center">
            <div className="text-white/80 text-3xl mb-4 font-bold">Mercury Ultra Visualizer</div>
            <div className="text-white/60 text-lg mb-4">Calm Colors  Reactive Movement</div>
            <div className="text-white/40 text-base space-y-1">
               Auto Evolution: shapes and movement sync to beats
              <br />
               Calm color flow: gentle, natural transitions disconnected from audio
              <br />
               Reactive droplets: movement responds to music while colors stay smooth
              <br />
               Fluid deformation: mercury blob morphs dramatically with beats
              <br />
               Full zoom control: scroll to zoom, drag to rotate and pan
              <br />
               Upload music to see the enhanced beat-reactive movement!
            </div>
          </div>
        </div>
      )}
      
      {/* PROMINENT AUTO EVOLUTION INDICATOR - Only show when actually active */}
      {isPlaying && audioSrc && controls.autoEvolution && controls.currentPhase && (
        <div className="absolute top-4 left-4 bg-gradient-to-r from-cyan-500/90 to-purple-500/90 text-white px-4 py-2 rounded-lg backdrop-blur-md border border-cyan-400/50 shadow-lg">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-green-400 rounded-full animate-pulse"></div>
            <span className="font-bold"> AUTO EVOLUTION ACTIVE</span>
          </div>
          <div className="text-xs text-cyan-100 mt-1">
            {controls.currentPhase}  {controls.currentPattern}
          </div>
        </div>
      )}
      
      {/* Manual Control Indicator */}
      {isPlaying && audioSrc && !controls.autoEvolution && (
        <div className="absolute top-4 left-4 bg-gradient-to-r from-orange-500/90 to-red-500/90 text-white px-4 py-2 rounded-lg backdrop-blur-md border border-orange-400/50 shadow-lg">
          <div className="flex items-center space-x-2">
            <div className="w-3 h-3 bg-orange-400 rounded-full"></div>
            <span className="font-bold"> MANUAL CONTROL</span>
          </div>
          <div className="text-xs text-orange-100 mt-1">
            All settings under your control
          </div>
        </div>
      )}
      
      {/* Enhanced debug info with animation progress */}
      {isPlaying && audioSrc && (
        <div className="absolute bottom-4 left-4 bg-black/80 text-white p-3 rounded text-sm font-mono space-y-1">
          <div className="text-green-400 font-bold"> Mercury Ultra Active</div>
          <div>Volume: {(safeAudioData.volume * 100).toFixed(0)}% | Bass: {(safeAudioData.bassLevel * 100).toFixed(0)}%</div>
          <div>Mid: {(safeAudioData.midLevel * 100).toFixed(0)}% | High: {(safeAudioData.highLevel * 100).toFixed(0)}%</div>
          <div className={controls.autoEvolution ? "text-cyan-300" : "text-orange-300"}>
            Mode: {controls.autoEvolution ? " Auto Evolution" : " Manual Control"}
          </div>
          {controls.currentPhase && controls.autoEvolution && (
            <div className="text-cyan-300">Phase: {controls.currentPhase}</div>
          )}
          {controls.currentPattern && controls.autoEvolution && (
            <div className="text-purple-300">Pattern: {controls.currentPattern}</div>
          )}
          {controls.elapsedTime && controls.autoEvolution && (
            <div className="text-yellow-300">Time: {Math.floor(controls.elapsedTime)}s</div>
          )}
          {controls.beatCount && controls.autoEvolution && (
            <div className="text-pink-300">Beats: {controls.beatCount}</div>
          )}
          <div className="text-blue-300">
            Droplets: {controls.dropletCount || 8} | Brightness: {((controls.dropletBrightness || 1.5) * 100).toFixed(0)}%
          </div>
        </div>
      )}
    </div>
  )
}

// Enhanced bass spheres
function BassSpheres({ audioData }: { audioData: any }) {
  const sphereRefs = useRef<THREE.Mesh[]>([])
  
  const sphereData = useMemo(() => {
    const data = []
    for (let i = 0; i < 8; i++) {
      data.push({
        initialPos: [
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 25,
          (Math.random() - 0.5) * 40
        ],
        velocity: [
          (Math.random() - 0.5) * 0.8,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.8
        ],
        phase: Math.random() * Math.PI * 2,
        speed: 0.4 + Math.random() * 0.6
      })
    }
    return data
  }, [])
  
  useFrame((state) => {
    const time = state.clock.elapsedTime
    const bassLevel = audioData.bassLevel
    
    sphereRefs.current.forEach((sphere, i) => {
      if (!sphere || !sphereData[i]) return
      
      const data = sphereData[i]
      const slowTime = time * data.speed * 0.2
      
      const x = data.initialPos[0] + Math.sin(slowTime + data.phase) * 4 + Math.cos(slowTime * 0.7) * 3
      const y = data.initialPos[1] + Math.cos(slowTime * 0.8 + data.phase) * 3 + Math.sin(slowTime * 0.5) * 2
      const z = data.initialPos[2] + Math.sin(slowTime * 0.6 + data.phase) * 3.5 + Math.cos(slowTime * 0.9) * 2.5
      
      sphere.position.set(x, y, z)
      
      const baseScale = 0.2 + bassLevel * 0.15
      sphere.scale.setScalar(baseScale)
      
      sphere.rotation.x += 0.004 * data.speed
      sphere.rotation.y += 0.003 * data.speed
      sphere.rotation.z += 0.002 * data.speed
      
      const material = sphere.material as THREE.MeshStandardMaterial
      if (material && material.emissiveIntensity !== undefined) {
        material.emissiveIntensity = bassLevel * 0.4
      }
    })
  })
  
  const spheres = sphereData.map((data, i) => (
    <mesh
      key={i}
      ref={(ref) => {
        if (ref) sphereRefs.current[i] = ref
      }}
      position={data.initialPos as [number, number, number]}
    >
      <sphereGeometry args={[0.2, 16, 16]} />
      <meshStandardMaterial 
        color="#00f2ff" 
        metalness={0.8} 
        roughness={0.2}
        emissive="#002244"
        emissiveIntensity={0.2}
        transparent={true}
        opacity={0.8}
      />
    </mesh>
  ))
  
  return <>{spheres}</>
} 